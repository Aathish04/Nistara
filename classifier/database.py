from logging import getLogger, basicConfig, INFO
from os import environ

import json
import hashlib 

from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider
from cassandra.query import dict_factory
from datetime import datetime
from dotenv import load_dotenv
load_dotenv()

basicConfig(level=INFO)
logger = getLogger(__name__)
INSTANCEID:int = int(environ.get('INSTANCEID', -2))

# This secure connect bundle is autogenerated when you download your SCB, 
# if yours is different update the file name below
cloud_config= {
  'secure_connect_bundle': 'secure-connect-nistaradb.zip'
}

# This token JSON file is autogenerated when you download your token, 
# if yours is different update the file name below
with open("NistaraDB-token.json") as f:
    secrets = json.load(f)

CLIENT_ID = secrets["clientId"]
CLIENT_SECRET = secrets["secret"]
auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
session = cluster.connect()
session.row_factory = dict_factory

UNSET_MATCHER_ID = UNSET_CLASSIFIER_ID = -1

logger.info("Connected to Cassandra cluster.")

def insertData():
    import uuid
    # Insert posts related to disasters
    prepared = session.prepare("INSERT INTO main.posts (id, userid, username, profilephoto, classifier, geolocation, isclassified, multimediaurl, textcontent, timestamp,lastupdatetimestamp,language,translator,isTranslated) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?);")

    # Data to be inserted
    posts = [
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user1', None, UNSET_CLASSIFIER_ID, (37.7749, -122.4194), False, ['url1'], 'Request for food and water supplies to assist affected families.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user2', None, UNSET_CLASSIFIER_ID, (29.7604, -95.3698), False, ['url2'], 'Urgent need for hygiene products including soap and sanitizers.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user3', None, UNSET_CLASSIFIER_ID, (40.7128, -74.0060), False, ['url3'], 'Emergency lighting and communication devices needed for affected areas.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user4', None, UNSET_CLASSIFIER_ID, (34.0522, -118.2437), False, ['url4'], 'Request for medicines and first aid kits.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user5', None, UNSET_CLASSIFIER_ID, (37.7749, -122.4194), False, ['url5'], 'Need tools and equipment for debris removal and rescue operations.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user6', None, UNSET_CLASSIFIER_ID, (34.0522, -118.2437), False, ['url6'], 'Request for clothing and shelter materials for displaced persons.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user7', None, UNSET_CLASSIFIER_ID, (40.7128, -74.0060), False, ['url7'], 'Safety and protection gear required for volunteers.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user8', None, UNSET_CLASSIFIER_ID, (37.7749, -122.4194), False, ['url8'], 'Request for evacuation assistance for elderly residents.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user9', None, UNSET_CLASSIFIER_ID, (29.7604, -95.3698), False, ['url9'], 'Searching for missing person: John Doe, last seen near the river.', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user9', None, UNSET_CLASSIFIER_ID, (29.7604, -95.3698), False, ['url9'], 'I have first aid kits to donate, please contact if u need them', datetime.utcnow(), datetime.utcnow(),'eng_Latn',-1,True),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user9', None, UNSET_CLASSIFIER_ID, (29.7604, -95.3698), False, ['url9'], 'यह एक परीक्षण वाक्य है', datetime.utcnow(), datetime.utcnow(),'hin_Deva',-1,False),
        (str(uuid.uuid4()), str(uuid.uuid4()), 'user9', None, UNSET_CLASSIFIER_ID, (29.7604, -95.3698), False, ['url9'], 'தானம் செய்ய என்னிடம் உணவு உள்ளது', datetime.utcnow(), datetime.utcnow(),'tam_Taml',-1,False),

    ]

    for post in posts:
        logger.debug(f"Inserting post: {post}")
        session.execute(prepared, post)
    
    logger.info("Inserted sample records.")

def getUnclassifiedPostInformation():
    query = f"SELECT * FROM main.POSTS WHERE (classifier IN (?,?)) AND isclassified=? and isTranslated=? LIMIT 1 ALLOW FILTERING"
    prepared_statement = session.prepare(query)
    row = session.execute(prepared_statement, (-1, INSTANCEID,False,True), trace=True)
    try:
        row_entry = row[0]
        logger.info(f"Got unclassified post: {row_entry}")
        
        query = f"UPDATE main.POSTS SET classifier=? WHERE id=?"
        prepared_statement = session.prepare(query)
        session.execute(prepared_statement, (INSTANCEID, row_entry["id"]), trace=True)
        logger.info(f"Acquired post {row_entry['id']}")
        
        query = f'SELECT classifier FROM MAIN.POSTS WHERE id=?'
        prepared_statement = session.prepare(query)
        result = session.execute(prepared_statement, (row_entry["id"],), trace=True)
        logger.info(f"Acquisition result: {result[0]}")
        
        return row_entry
    except IndexError:
        logger.warning("No unclassified posts.")
        return None
def putExtractedInformation(extracted_info, post_data):
    logger.debug(f"Extracted information: {extracted_info}")
    logger.debug(f"Post data: {post_data}")
    
    postclass = str(extracted_info['category'])
    userid = str(post_data['userid'])
    multimediaurl = post_data['multimediaurl']
    postid = str(post_data['id'])
    profilephoto = post_data['profilephoto']
    textualinfo = post_data['textcontent']
    username = post_data['username']
    isComplete = False
    timestamp = post_data['timestamp']
    geolocation = post_data['geolocation']

    combined = {**post_data, **extracted_info}
    combined_str = str(combined).encode()
    result = hashlib.sha256(combined_str)
    
    if postclass == 'OFFER':
        for item in extracted_info['items']:
            combined_per_item = {**post_data, **item}
            combined_per_item_str = str(combined_per_item).encode()
            result = hashlib.sha256(combined_per_item_str)
            donationid = result.hexdigest()
            
            item_name = item['itemName']
            class_ = item["class"]
            
            if item['quantity']:
                quantity = int(item['quantity']) or None
            else:
                quantity = None
                
            # Correct order of fields
            prepared = session.prepare("INSERT INTO main.donations (id, umbrellatype, postid, userid, item, quantity, postclass, geolocation, ismatched, username, profilephoto, timestamp, translatedtextcontent, matcherid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);")
            session.execute(prepared, (str(donationid), class_ , postid, userid, item_name, quantity,postclass, geolocation, False, username, profilephoto, timestamp, textualinfo, UNSET_MATCHER_ID))
            logger.info(f"Inserted donation: {donationid}")

    elif postclass == 'REQUEST_EVACUATION' or postclass == 'REQUEST_SEARCH':
        # Correct order of fields
        prepared = session.prepare("INSERT INTO main.requests (id, umbrellatype, postid, userid, item, quantity, postclass, geolocation, ismatched, username, profilephoto, timestamp, translatedtextcontent, matcherid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);")
        combined_str = str({**post_data, **extracted_info}).encode()
        result = hashlib.sha256(combined_str)
        requestid = result.hexdigest()
        session.execute(prepared, (requestid, None , postid, userid, None, None, postclass, geolocation, False, username, profilephoto, timestamp, textualinfo, UNSET_MATCHER_ID))
        logger.info(f"Inserted search request: {requestid}")

    elif postclass == 'REQUEST_ITEM':
        for item in extracted_info['items']:
            combined_per_item = {**post_data, **item}
            combined_per_item_str = str(combined_per_item).encode()
            result = hashlib.sha256(combined_per_item_str)
            requestid = result.hexdigest()
            
            item_name = item['itemName']
            class_ = item['class']

            if item['quantity']:
                quantity = int(item['quantity']) or None
            else:
                quantity = None
            
            prepared = session.prepare("INSERT INTO main.requests (id, umbrellatype, postid, userid, item, quantity, postclass, geolocation, ismatched, username, profilephoto, timestamp, translatedtextcontent, matcherid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);")
            session.execute(prepared, (requestid, class_ , postid, userid, item_name, quantity, postclass, geolocation, False, username, profilephoto, timestamp, textualinfo, UNSET_MATCHER_ID))
            logger.info(f"Inserted item request of type {class_}: {requestid}")

    update_query = "UPDATE main.posts SET lastupdatetimestamp = ?, isclassified = ?, class = ? WHERE id = ?;"
    prepared_statement = session.prepare(update_query)
    session.execute(prepared_statement, (datetime.utcnow(), True, postclass, postid))
    logger.info(f"Updated post {postid} as classified with tag {postclass}")


if __name__ == "__main__":
    insertData()